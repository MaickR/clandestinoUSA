/* assets/js/script.js
   Modernized and commented.
   - Uses data-preload attribute (fixed typo)
   - Adds simple debounce for scroll handlers
   - Keeps slider, nav toggle, parallax behavior as original
*/

'use strict';

/* ------------------------------
   Helper: Select element safely
   ------------------------------ */
const $ = (selector) => document.querySelector(selector);
const $$ = (selector) => Array.from(document.querySelectorAll(selector));

/* ------------------------------
   Clandestino Preloader
   ------------------------------ */
(function(){
  var pre = document.querySelector('.clandestino-preloader');
  if(!pre) return;

  var progressBar = pre.querySelector('.clandestino-preloader-progress-bar');
  var progressText = pre.querySelector('.clandestino-preloader-progress-text');
  
  document.documentElement.classList.add('clandestino-preloader-lock');
  document.body.classList.add('clandestino-preloader-lock');

  // Simulador de progreso más realista
  var progress = 0;
  var progressInterval;
  
  function updateProgress() {
    if (progress < 90) {
      // Progreso más rápido al inicio, más lento cerca del final
      var increment = progress < 30 ? 2 : progress < 60 ? 1.5 : 0.5;
      progress += increment;
      
      if (progressBar) {
        progressBar.style.width = progress + '%';
      }
    }
  }
  
  // Iniciar simulación de progreso
  progressInterval = setInterval(updateProgress, 100);

  function hidePreloader(){
    if(!pre) return;
    
    // Completar la barra antes de ocultar
    if (progressBar) {
      progressBar.style.width = '100%';
    }
    
    clearInterval(progressInterval);
    
    setTimeout(function() {
      pre.classList.add('_hide');
      document.documentElement.classList.remove('clandestino-preloader-lock');
      document.body.classList.remove('clandestino-preloader-lock');
      
      // Remover del DOM tras transición
      setTimeout(function(){
        if(pre && pre.parentNode){
          pre.parentNode.removeChild(pre);
          pre = null;
        }
        
        // Mostrar modal de cierre temporal solo en index.html
        if (window.location.pathname === '/' || 
            window.location.pathname.endsWith('/index.html') ||
            window.location.pathname.endsWith('/')) {
          initClosureModal();
        }
      }, 800);
    }, 200);
  }

  // Fallback si load tarda demasiado (10s)
  var fallback = setTimeout(hidePreloader, 10000);

  window.addEventListener('load', function(){
    clearTimeout(fallback);
    // Asegurar que el progreso esté completo antes de ocultar
    progress = 100;
    setTimeout(hidePreloader, 600);
  });
})();

/* ----------------------------------
   Reservation & Events Form Logic
----------------------------------- */
(function initReservationForm(){
  const form = document.getElementById('clandestino-reservation-form');
  if(!form) return; // exit if form not on page

  const guestsEl = form.querySelector('select[name="guests"]');
  const dateEl = form.querySelector('input[name="date"]'); // now hidden; updated via inline calendar
  const timeEl = form.querySelector('select[name="time"]');
  const eventTypeEl = form.querySelector('select[name="eventType"]');
  const customWrap = form.querySelector('#custom-event-extra');
  const priceAmountEl = document.getElementById('estimated-price');
  const breakdownEl = document.getElementById('price-breakdown');
  const availabilityStatus = document.getElementById('availability-status');
  const calendarContainer = document.getElementById('mini-calendar');
  const submitBtn = document.getElementById('reservation-submit');

  // Set min date = today + 48h (2 días de anticipación)
  const now = new Date();
  const minDateObj = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  minDateObj.setDate(minDateObj.getDate() + 2); // 48 horas
  const minDateISO = minDateObj.toISOString().split('T')[0];
  // hidden date input doesn't require min attribute; calendar enforces rule

  // Mock existing reservations (would come from backend in future)
  // Format: 'YYYY-MM-DD|HH:MM'
  const busySlots = new Set();
  // Load pre-defined demo conflicts (minDate + 1 & +2 to illustrate; still respect 48h rule if applies)
  const demo1 = new Date(minDateObj); demo1.setDate(demo1.getDate()+1); busySlots.add(`${demo1.toISOString().split('T')[0]}|17:00`);
  const demo2 = new Date(minDateObj); demo2.setDate(demo2.getDate()+2); busySlots.add(`${demo2.toISOString().split('T')[0]}|18:00`);

  // Local storage persistence for client-side collision (no backend yet)
  const LS_KEY = 'clandestinoReservations';
  function loadStoredReservations(){
    try { return JSON.parse(localStorage.getItem(LS_KEY)) || []; } catch(e){ return []; }
  }
  function saveStoredReservation(dateStr, timeStr, name, guests){
    const data = loadStoredReservations();
    data.push({ dt:`${dateStr}|${timeStr}`, name: name.slice(0,60), guests, ts: Date.now() });
    localStorage.setItem(LS_KEY, JSON.stringify(data));
  }
  function storedIsBusy(dateStr, timeStr){
    const key = `${dateStr}|${timeStr}`;
    return loadStoredReservations().some(r=> r.dt === key);
  }
  function pruneOldReservations(){
    const data = loadStoredReservations();
    const keep = data.filter(r=>{
      const [d] = r.dt.split('|');
      return d >= minDateISO; // discard anything before min date threshold
    });
    localStorage.setItem(LS_KEY, JSON.stringify(keep));
  }
  pruneOldReservations();

  // Pricing configuration (realistic heuristic – moderated values)
  // Base price per guest approximates an average spend expectation (food + basic beverage)
  const basePerGuest = {
    standard: 17,
    romantic: 28,
    birthday: 22,
    anniversary: 24,
    family: 18,
    holiday: 26,
    tasting: 35,
    corporate: 30,
    custom: 22 // starting point; custom extras adjust
  };
  // Evening (dinner) slight uplift; earlier hours no premium
  const timePremium = (time) => {
    if(!time) return 0; const hour = parseInt(time.split(':')[0],10);
    if(hour >= 19) return 0.07; // after 7 pm
    if(hour >= 18) return 0.05; // 6–6:59 pm
    return 0;
  };
  // Weekends (Fri/Sat) and Sunday brunch style slight uplift
  const weekendPremium = (dateStr) => {
    if(!dateStr) return 0; const dt = new Date(dateStr+'T00:00:00');
    const day = dt.getDay(); // 0=Sun 6=Sat
    return (day === 5 || day === 6) ? 0.08 : (day === 0 ? 0.05 : 0);
  };

  function formatUSD(v){ return '$'+Math.round(v); }

  function computePrice(){
    const guests = parseInt(guestsEl.value||'0',10); if(!guests){ priceAmountEl.textContent = '$0'; breakdownEl.innerHTML=''; return; }
    const type = eventTypeEl.value || 'standard';
    const dateStr = dateEl.value; const timeStr = timeEl.value;
    const baseGuest = basePerGuest[type] || basePerGuest.standard;
    let subtotal = guests * baseGuest;
    const weekendP = weekendPremium(dateStr);
    const timeP = timePremium(timeStr);
    const premiumMultiplier = 1 + weekendP + timeP;
    let adjusted = subtotal * premiumMultiplier;

    // custom adjustments
    let customAdj = 0; const lines = [];
    lines.push(`<li><span>Base (${guests} x ${formatUSD(baseGuest)})</span><span>${formatUSD(subtotal)}</span></li>`);
    if(weekendP){ const wv = subtotal*weekendP; lines.push(`<li><span>Weekend Adj.</span><span>${formatUSD(wv)}</span></li>`); }
    if(timeP){ const tv = subtotal*timeP; lines.push(`<li><span>Evening Adj.</span><span>${formatUSD(tv)}</span></li>`); }

    // Moderated fixed add-ons
    if(type === 'romantic') { customAdj += 18; lines.push(`<li><span>Romantic Touch</span><span>${formatUSD(18)}</span></li>`); }
    if(type === 'tasting') { customAdj += 12; lines.push(`<li><span>Tasting Curation</span><span>${formatUSD(12)}</span></li>`); }
    if(type === 'corporate') { customAdj += 25; lines.push(`<li><span>Corporate Setup</span><span>${formatUSD(25)}</span></li>`); }
    if(type === 'holiday') { customAdj += 20; lines.push(`<li><span>Seasonal Elements</span><span>${formatUSD(20)}</span></li>`); }
    if(type === 'custom') {
      const duration = parseInt(form.duration?.value||'0',10);
      if(duration>0){ const v= duration*10; customAdj += v; lines.push(`<li><span>Extra Duration (${duration}h)</span><span>${formatUSD(v)}</span></li>`); }
      const winePref = form.winePreference?.value;
      if(winePref==='premium'){ customAdj += 40; lines.push(`<li><span>Premium Wine Focus</span><span>${formatUSD(40)}</span></li>`); }
      if(winePref==='mixed'){ customAdj += 18; lines.push(`<li><span>Mixed Wine Selection</span><span>${formatUSD(18)}</span></li>`); }
    }
    adjusted += customAdj;
    const serviceFee = adjusted * 0.10; lines.push(`<li><span>Est. Service & Tax (10%)</span><span>${formatUSD(serviceFee)}</span></li>`);
    let total = adjusted + serviceFee;
    // Soft sanity bounds (avoid extreme low/high due to any unforeseen input)
    if(total < guests * 12) total = guests * 12; // enforce sensible floor
    priceAmountEl.textContent = formatUSD(total);
    breakdownEl.innerHTML = lines.join('');
    priceAmountEl.dataset.base = total.toFixed(0);
  }

  function toggleCustom(){
    if(eventTypeEl.value === 'custom'){ customWrap.classList.remove('hidden'); customWrap.setAttribute('aria-hidden','false'); }
    else { customWrap.classList.add('hidden'); customWrap.setAttribute('aria-hidden','true'); }
    computePrice();
  }

  // Basic availability check
  function isPastDateTime(dateStr, timeStr){
    if(!dateStr) return false;
    const [h,m] = (timeStr||'00:00').split(':').map(n=>parseInt(n,10));
    const dt = new Date(`${dateStr}T${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:00`);
    return dt.getTime() < Date.now();
  }

  function suggestNext(dateStr, timeStr){
    // Simple suggestion: increment 30 minutes up to +3 hours; else next day same time.
    const [h,m] = timeStr.split(':');
    let dt = new Date(`${dateStr}T${h}:${m}:00`);
    for(let i=0;i<6;i++) { // 6 * 30min = 3h
      dt = new Date(dt.getTime() + 30*60000);
      const dIso = dt.toISOString().split('T')[0];
      const tIso = dt.toTimeString().slice(0,5);
      if(dIso < minDateISO) continue;
      if(!busySlots.has(`${dIso}|${tIso}`) && !storedIsBusy(dIso,tIso)) return `${dIso} ${tIso}`;
    }
    // Next day same time
    const base = new Date(`${dateStr}T${h}:${m}:00`); base.setDate(base.getDate()+1);
    const dIso = base.toISOString().split('T')[0]; const tIso = `${h}:${m}`;
    if(!busySlots.has(`${dIso}|${tIso}`) && !storedIsBusy(dIso,tIso)) return `${dIso} ${tIso}`;
    return null;
  }

  function checkAvailability(){
    const d = dateEl.value; const t = timeEl.value; 
    if(!d || !t){ availabilityStatus.textContent='Seleccione fecha y hora.'; availabilityStatus.className='availability-status'; return; }
    // Enforce 48h rule
    if(d < minDateISO){
      availabilityStatus.textContent='Debe reservar con mínimo 48 horas de anticipación.';
      availabilityStatus.className='availability-status conflict';
      submitBtn.disabled = true; return;
    }
    // Past time check (same day/time earlier than now)
    if(isPastDateTime(d,t)){
      availabilityStatus.textContent='La hora seleccionada ya pasó.';
      availabilityStatus.className='availability-status conflict';
      submitBtn.disabled = true; return;
    }
    const key = `${d}|${t}`;
    if(busySlots.has(key) || storedIsBusy(d,t)) {
      const suggestion = suggestNext(d,t);
      availabilityStatus.textContent='Ese horario ya está reservado.' + (suggestion ? ` Sugerencia: ${suggestion}` : ' Elija otro.');
      availabilityStatus.className='availability-status conflict';
      submitBtn.disabled = true;
    } else {
      availabilityStatus.textContent='Disponible provisionalmente.';
      availabilityStatus.className='availability-status ok';
    }
  }

  // Minimal inline calendar (current month only navigation)
  function buildCalendar(baseDate){
    calendarContainer.innerHTML='';
    const header = document.createElement('div'); header.className='calendar-header';
    const prevBtn = document.createElement('button'); prevBtn.className='calendar-nav'; prevBtn.type='button'; prevBtn.innerHTML='&#8249;';
    const nextBtn = document.createElement('button'); nextBtn.className='calendar-nav'; nextBtn.type='button'; nextBtn.innerHTML='&#8250;';
    const title = document.createElement('div'); title.style.fontSize='1.2rem'; title.style.fontWeight='600';
    header.append(prevBtn,title,nextBtn); calendarContainer.appendChild(header);
  const month = baseDate.getMonth(); const year = baseDate.getFullYear();
    title.textContent = baseDate.toLocaleString(undefined,{month:'long', year:'numeric'});
    const weekdays = ['Su','Mo','Tu','We','Th','Fr','Sa'];
    weekdays.forEach(d=>{ const w=document.createElement('div'); w.textContent=d; w.className='weekday'; calendarContainer.appendChild(w); });
    const first = new Date(year,month,1); const startDay = first.getDay();
    for(let i=0;i<startDay;i++){ const pad=document.createElement('div'); calendarContainer.appendChild(pad); }
    const daysInMonth = new Date(year,month+1,0).getDate();
    for(let day=1; day<=daysInMonth; day++){
      const dateStr = `${year}-${String(month+1).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
      const btn = document.createElement('button'); btn.type='button'; btn.textContent=day; btn.className='day';
      if(dateStr < minDateISO){ btn.classList.add('unavailable'); }
      btn.addEventListener('click',()=>{
        if(btn.classList.contains('unavailable')) return;
        dateEl.value = dateStr; calendarContainer.querySelectorAll('.day').forEach(b=>b.classList.remove('selected')); btn.classList.add('selected'); checkAvailability(); computePrice(); enableSubmitCheck();
      });
      if(dateEl.value === dateStr) btn.classList.add('selected');
      calendarContainer.appendChild(btn);
    }
    prevBtn.addEventListener('click',()=>{ baseDate.setMonth(baseDate.getMonth()-1); buildCalendar(baseDate); });
    nextBtn.addEventListener('click',()=>{ baseDate.setMonth(baseDate.getMonth()+1); buildCalendar(baseDate); });
  }
  const calBase = new Date(); buildCalendar(calBase);
  calendarContainer.setAttribute('aria-hidden','false');

  function enableSubmitCheck(){
    if(!form.accept.checked){ submitBtn.disabled=true; return; }
    const requiredValid = form.checkValidity();
    submitBtn.disabled = !requiredValid;
  }

  // Event listeners
  ['change','input'].forEach(ev=>{
    form.addEventListener(ev, (e)=>{
      if(e.target === eventTypeEl) toggleCustom();
  if(e.target === guestsEl || e.target === timeEl || e.target.closest('#custom-event-extra')) computePrice();
  if(e.target === timeEl) checkAvailability();
      enableSubmitCheck();
    });
  });
  form.accept.addEventListener('change', enableSubmitCheck);

  // Initial compute
  computePrice(); checkAvailability(); enableSubmitCheck();

  // Form submission -> WhatsApp redirect
  function sanitize(val){
    if(!val) return '';
    return String(val).replace(/[<>]/g,'').trim().slice(0,180); // basic XSS & length guard
  }
  function normalizePhone(ph){ return (ph||'').replace(/[^0-9+]/g,'').slice(0,18); }

  form.addEventListener('submit', function(e){
    e.preventDefault(); if(submitBtn.disabled) return;
    computePrice();
    const formData = new FormData(form);
    const diets = form.querySelectorAll('input[name="diet"]:checked');
    const dietValues = Array.from(diets).map(d=>d.value).join(', ') || 'None';
    const estimate = priceAmountEl.dataset.base || '0';
    const lines = [];
    lines.push('*Reservation Request*');
    lines.push(`Name: ${sanitize(formData.get('name'))}`);
    lines.push(`Phone: ${normalizePhone(formData.get('phone'))}`);
    lines.push(`Guests: ${sanitize(formData.get('guests'))}`);
    lines.push(`Date: ${sanitize(formData.get('date'))}`);
    lines.push(`Time: ${sanitize(formData.get('time'))}`);
    lines.push(`Event Type: ${sanitize(formData.get('eventType'))}`);
    if(formData.get('eventType')==='custom'){
      if(formData.get('customTitle')) lines.push(`Custom Title: ${sanitize(formData.get('customTitle'))}`);
      if(formData.get('duration')) lines.push(`Duration (h): ${sanitize(formData.get('duration'))}`);
      if(formData.get('winePreference')) lines.push(`Wine Pref: ${sanitize(formData.get('winePreference'))}`);
    }
    lines.push(`Dietary: ${dietValues}`);
    if(formData.get('budget')) lines.push(`Budget: ${sanitize(formData.get('budget'))}`);
    if(formData.get('notes')) lines.push(`Notes: ${sanitize(formData.get('notes'))}`);
    lines.push(`Estimated: $${estimate} (subject to confirmation)`);
    const msg = encodeURIComponent(lines.join('\n'));
  // Persist slot locally to avoid duplicates on this device
  saveStoredReservation(sanitize(formData.get('date')), sanitize(formData.get('time')), sanitize(formData.get('name')), sanitize(formData.get('guests')));
  const whatsappNumber = '14086090027';
  const url = `https://wa.me/${whatsappNumber}?text=${msg}`;
  window.open(url, '_blank');
  checkAvailability(); // refresh status to reflect new busy slot
  });
})();

/* ------------------------------
   Utility: addEventOnElements
   ------------------------------ */
const addEventOnElements = (elements, eventType, callback) => {
  elements.forEach((el) => el.addEventListener(eventType, callback));
};

/* ------------------------------
   NAV toggler
   ------------------------------ */
const navbar = $('[data-navbar]');
const navTogglers = $$('[data-nav-toggler]');
const overlay = $('[data-overlay]');
const toggleNavbar = () => {
  if (!navbar) return;
  navbar.classList.toggle('active');
  if (overlay) overlay.classList.toggle('active');
  document.body.classList.toggle('nav-active');
};
addEventOnElements(navTogglers, 'click', toggleNavbar);

/* ------------------------------
   Submenu (desktop hover + mobile/tablet click <=1024px)
   ------------------------------ */
(function initSubmenus(){
  const SUBMENU_BREAKPOINT = 1024; // match CSS
  const items = $$('.has-submenu');
  if(!items.length) return;

  items.forEach(item => {
    const link = item.querySelector(':scope > .navbar-link');
    const submenu = item.querySelector(':scope > .submenu');
    if(!link || !submenu) return;

    // Inject indicator icon only once
    if(!link.querySelector('.submenu-toggle-icon')){
      const icon = document.createElement('span');
      icon.className = 'submenu-toggle-icon';
      icon.setAttribute('aria-hidden','true');
      icon.innerHTML = '▾';
      link.appendChild(icon);
    }

    // Accessibility attributes
    link.setAttribute('aria-haspopup','true');
    link.setAttribute('aria-expanded','false');
    submenu.setAttribute('role','menu');

    // Click toggling for all breakpoints: open/close on click (desktop + mobile/tablet)
    link.addEventListener('click', (e)=>{
      e.preventDefault();
      const isOpen = item.classList.toggle('open');
      link.setAttribute('aria-expanded', String(isOpen));
    });
  });

  // Close on outside click (mobile/tablet only)
  document.addEventListener('click', (e)=>{
    if(window.innerWidth > SUBMENU_BREAKPOINT) return;
    if(!e.target.closest('.has-submenu')){
      items.forEach(it=>{
        if(it.classList.contains('open')){
          it.classList.remove('open');
          const l = it.querySelector(':scope > .navbar-link');
          l && l.setAttribute('aria-expanded','false');
        }
      });
    }
  });

  // Close all on ESC
  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape'){
      items.forEach(it=>{
        if(it.classList.contains('open')){
          it.classList.remove('open');
          const l = it.querySelector(':scope > .navbar-link');
          l && l.setAttribute('aria-expanded','false');
        }
      });
    }
  });

  // Close any open submenus when resizing to desktop to avoid stale states
  window.addEventListener('resize', ()=>{
    if(window.innerWidth > SUBMENU_BREAKPOINT){
      $$('.has-submenu.open').forEach(i=>{
        i.classList.remove('open');
        const l = i.querySelector(':scope > .navbar-link');
        l && l.setAttribute('aria-expanded','false');
      });
    }
  });
})();

/* ------------------------------
   Header hide on scroll (debounced)
   ------------------------------ */
const header = $('[data-header]');
const backTopBtn = $('[data-back-top-btn]');
let lastScrollPos = 0;
let scrollTimeout = null;

const hideHeader = () => {
  const isScrollDown = lastScrollPos < window.scrollY;
  if (isScrollDown) {
    header && header.classList.add('hide');
  } else {
    header && header.classList.remove('hide');
  }
  lastScrollPos = window.scrollY;
};

// Passive listener improves scroll performance and avoids blocking main thread
window.addEventListener('scroll', () => {
  if (window.scrollY >= 50) {
    header && header.classList.add('active');
    backTopBtn && backTopBtn.classList.add('active');
    // Debounce hideHeader to avoid thrashing
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(hideHeader, 50);
  } else {
    header && header.classList.remove('active');
    backTopBtn && backTopBtn.classList.remove('active');
    header && header.classList.remove('hide');
  }
}, { passive: true });

/* ------------------------------
   HERO slider
   ------------------------------ */
const heroSlider = $('[data-hero-slider]');
const heroSliderItems = $$('[data-hero-slider-item]');
const heroSliderPrevBtn = $('[data-prev-btn]');
const heroSliderNextBtn = $('[data-next-btn]');

let currentSlidePos = 0;
let lastActiveSliderItem = heroSliderItems[0];

const updateSliderPos = () => {
  if (!lastActiveSliderItem) return;
  lastActiveSliderItem.classList.remove('active');
  heroSliderItems[currentSlidePos].classList.add('active');
  lastActiveSliderItem = heroSliderItems[currentSlidePos];
};

const slideNext = () => {
  if (currentSlidePos >= heroSliderItems.length - 1) currentSlidePos = 0;
  else currentSlidePos++;
  updateSliderPos();
};

const slidePrev = () => {
  if (currentSlidePos <= 0) currentSlidePos = heroSliderItems.length - 1;
  else currentSlidePos--;
  updateSliderPos();
};

heroSliderNextBtn && heroSliderNextBtn.addEventListener('click', slideNext);
heroSliderPrevBtn && heroSliderPrevBtn.addEventListener('click', slidePrev);

/* Auto slide with pause on hover (keeps original UX) */
let autoSlideInterval;
const autoSlide = () => {
  autoSlideInterval = setInterval(slideNext, 7000);
};
window.addEventListener('load', autoSlide);
addEventOnElements([heroSliderNextBtn, heroSliderPrevBtn].filter(Boolean), 'mouseover', () => clearInterval(autoSlideInterval));
addEventOnElements([heroSliderNextBtn, heroSliderPrevBtn].filter(Boolean), 'mouseout', autoSlide);

/* ------------------------------
   Parallax (mouse move)
   ------------------------------ */
const parallaxItems = $$('[data-parallax-item]');
// Throttle mousemove to ~60-100ms to reduce layout/paint cost
let lastMove = 0;
window.addEventListener('mousemove', (event) => {
  const now = performance.now();
  if (now - lastMove < 80) return; // ~12 fps for parallax is sufficient
  lastMove = now;
  // normalized cursor offsets
  const nx = (event.clientX / window.innerWidth) * 10 - 5;
  const ny = (event.clientY / window.innerHeight) * 10 - 5;
  for (let i = 0; i < parallaxItems.length; i++) {
    const speed = Number(parallaxItems[i].dataset.parallaxSpeed) || 1;
    const tx = nx * speed * -1;
    const ty = ny * speed * -1;
    parallaxItems[i].style.transform = `translate3d(${tx}px, ${ty}px, 0)`;
  }
}, { passive: true });

/* ------------------------------
   CTA Booking Animation (Global)
   ------------------------------ */
const initCtaBookingAnimation = () => {
  const ctaItems = $$('.clandestino-cta-booking .cta-anim[data-animate="active"]');
  if (!ctaItems.length) return;
  
  // Fallback for browsers without IntersectionObserver
  if (!('IntersectionObserver' in window)) {
    ctaItems.forEach(el => el.classList.add('is-visible'));
    return;
  }
  
  // IntersectionObserver for scroll-triggered animations
  const ctaObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('is-visible');
        ctaObserver.unobserve(entry.target);
      }
    });
  }, { 
    threshold: 0.15,
    rootMargin: '0px 0px -50px 0px' // Trigger slightly before element is fully visible
  });
  
  ctaItems.forEach(el => ctaObserver.observe(el));
};

// Initialize CTA animations when DOM is ready
document.addEventListener('DOMContentLoaded', initCtaBookingAnimation);
window.addEventListener('load', initCtaBookingAnimation); // Fallback for dynamic content


// Clandestino SWC History Section
(function initClandestinoSwcHistory(){
  const root = document.querySelector('.clandestino-swc-history');
  if(!root) return;

  // Scroll reveal animations - but carousel slides should always be visible
  const animEls = root.querySelectorAll('.scroll-animate');
  const carouselSlides = root.querySelectorAll('.clandestino-swc-carousel .scroll-animate');
  
  // Immediately activate all carousel slides
  carouselSlides.forEach(el => el.classList.add('active'));
  
  // Handle other scroll animations normally
  const otherAnimEls = Array.from(animEls).filter(el => !el.closest('.clandestino-swc-carousel'));
  if('IntersectionObserver' in window && otherAnimEls.length){
    const io = new IntersectionObserver(entries=>{
      entries.forEach(en=>{
        if(en.isIntersecting){ 
          en.target.classList.add('active'); 
          io.unobserve(en.target); 
        }
      });
    }, { threshold: 0.1, rootMargin: '0px 0px -10% 0px' });
    otherAnimEls.forEach(el=> io.observe(el));
  } else {
    otherAnimEls.forEach(el=> el.classList.add('active'));
  }

  // Swiper initialization
  const container = root.querySelector('.swiper-container');
  if(!container || typeof Swiper === 'undefined') return;
  
  try {
    // eslint-disable-next-line no-undef
    const clandestinoSwcSwiper = new Swiper(container, {
      slidesPerView: 1,
      spaceBetween: 0,
      centeredSlides: true,
      loop: true,
      loopAdditionalSlides: 2,
      speed: 800,
      autoHeight: false,
      watchOverflow: false,
      preloadImages: true,
      updateOnWindowResize: true,
      loopPreventsSliding: false,
      autoplay: {
        delay: 6500,
        disableOnInteraction: false,
        pauseOnMouseEnter: true,
        waitForTransition: true
      },
      effect: 'slide',
      grabCursor: true,
      allowTouchMove: true,
      breakpoints: {
        0: { slidesPerView: 1, centeredSlides: true, spaceBetween: 14 },
        520: { slidesPerView: 1, centeredSlides: true, spaceBetween: 18 },
        768: { slidesPerView: 1, centeredSlides: true, spaceBetween: 22 },
        1024: { slidesPerView: 1, centeredSlides: true, spaceBetween: 0 }
      },
      on: {
        beforeTransitionStart: function(){
          this.slides.forEach(sl => {
            const it = sl.querySelector('.clandestino-swc-item');
            if(it) it.style.transform = '';
          });
        },
        slideChangeTransitionStart: function() {
          const activeSlide = this.slides[this.activeIndex];
          if(activeSlide) {
            const item = activeSlide.querySelector('.clandestino-swc-item');
            if(item) {
              item.style.transition = 'transform .5s ease';
              item.style.transform = 'scale(0.965)';
              requestAnimationFrame(()=>{
                setTimeout(()=>{ item.style.transform = 'scale(1)'; }, 50);
              });
            }
          }
        }
      }
    });

    // Pause autoplay on hover for accessibility
    root.addEventListener('mouseenter', ()=> {
      if(clandestinoSwcSwiper.autoplay) {
        clandestinoSwcSwiper.autoplay.stop();
      }
    });
    
    root.addEventListener('mouseleave', ()=> {
      if(clandestinoSwcSwiper.autoplay) {
        clandestinoSwcSwiper.autoplay.start();
      }
    });

    // Basic keyboard navigation retained (left/right) for accessibility
    document.addEventListener('keydown', (e) => {
      if(e.key === 'ArrowLeft') clandestinoSwcSwiper.slidePrev();
      if(e.key === 'ArrowRight') clandestinoSwcSwiper.slideNext();
    });

  } catch(e){ 
    console.warn('Clandestino SWC Swiper initialization failed:', e); 
  }
})();

/* Testimonials Carousel */
(function initTestimonialsCarousel(){
  const container = document.querySelector('.testimonials-carousel .swiper-container');
  if (!container) return;

  const ensureSwiper = () => {
    return new Promise((resolve) => {
      if (window.Swiper) return resolve();
      const s = document.createElement('script');
      s.src = 'https://unpkg.com/swiper@6.8.4/swiper-bundle.min.js';
      s.async = true;
      s.onload = () => resolve();
      document.head.appendChild(s);
    });
  };

  ensureSwiper().then(() => {
    try {
      const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const totalSlides = container.querySelectorAll('.swiper-wrapper > .swiper-slide').length;
      // eslint-disable-next-line no-undef
      const testiSwiper = new Swiper(container, {
        loop: true,
        speed: 600,
        spaceBetween: 24,
        autoHeight: true, // allow Swiper to adjust height to video content
        grabCursor: true,
        centeredSlides: false,
        watchOverflow: false,
        autoplay: reduceMotion ? false : { delay: 6000, disableOnInteraction: false },
        slidesPerView: 3,
        breakpoints: {
          0: { slidesPerView: 1, spaceBetween: 16, centeredSlides: true },
          768: { slidesPerView: 2, spaceBetween: 20 },
          1024: { slidesPerView: 2, spaceBetween: 20 },
          1200: { slidesPerView: 3, spaceBetween: 24 }
        },
        pagination: {
          el: '.testimonials-carousel .swiper-pagination',
          type: 'progressbar'
        }
      });

      const paginationEl = container.querySelector('.swiper-pagination');
      if (paginationEl) {
        paginationEl.classList.add('testimonials-progressbar');
        paginationEl.setAttribute('role', 'progressbar');
        paginationEl.setAttribute('aria-valuemin', '1');
        paginationEl.setAttribute('aria-valuemax', String(totalSlides));
      }

      const statusEl = container.parentElement.querySelector('.testimonials-pagination-status');

      const updateStatus = () => {
        if (!statusEl) return;
        const current = testiSwiper.realIndex + 1;
        const formattedCurrent = current.toString().padStart(2, '0');
        const formattedTotal = totalSlides.toString().padStart(2, '0');

        statusEl.setAttribute('aria-label', `Client story ${current} of ${totalSlides}`);
        statusEl.innerHTML = `
          <span class="status-prefix">Client Stories</span>
          <span class="status-count">
            <span class="status-current">${formattedCurrent}</span>
            <span class="status-divider" aria-hidden="true">/</span>
            <span class="status-total">${formattedTotal}</span>
          </span>
        `;

        if (paginationEl) {
          paginationEl.setAttribute('aria-valuenow', String(current));
        }
      };

      updateStatus();
      testiSwiper.on('slideChange', updateStatus);
      testiSwiper.on('loopFix', updateStatus);

      // Pause on hover (autoplay) and ensure proper behavior
      if (testiSwiper.autoplay) {
        container.addEventListener('mouseenter', () => testiSwiper.autoplay && testiSwiper.autoplay.stop && testiSwiper.autoplay.stop());
        container.addEventListener('mouseleave', () => testiSwiper.autoplay && testiSwiper.autoplay.start && testiSwiper.autoplay.start());
      }

      // When a video is played, stop autoplay and lock swiper interactions
      container.addEventListener('play', (e) => {
        const vid = e.target;
        if (vid && vid.tagName === 'VIDEO') {
          // stop autoplay if present
          if (testiSwiper.autoplay && testiSwiper.autoplay.running) testiSwiper.autoplay.stop();
          // disable swiping while playing
          testiSwiper.allowTouchMove = false;
          testiSwiper.allowSlideNext = false;
          testiSwiper.allowSlidePrev = false;
        }
      }, true);

      // When a video is paused or ended, resume autoplay and re-enable interactions
      function resumeAfterVideo(e) {
        const vid = e.target;
        if (vid && vid.tagName === 'VIDEO') {
          // re-enable swiping
          testiSwiper.allowTouchMove = true;
          testiSwiper.allowSlideNext = true;
          testiSwiper.allowSlidePrev = true;
          // resume autoplay if configured
          if (testiSwiper.autoplay && !testiSwiper.autoplay.running && !reduceMotion) {
            testiSwiper.autoplay.start();
          }
          // update swiper height to make sure layout settles
          setTimeout(() => testiSwiper.updateAutoHeight(300), 50);
        }
      }

      container.addEventListener('pause', resumeAfterVideo, true);
      container.addEventListener('ended', resumeAfterVideo, true);

      // Accessibility: keyboard play/pause toggles should also stop autoplay
      container.addEventListener('keydown', (e) => {
        if (e.key === ' ' || e.key === 'Enter') {
          const active = container.querySelector('.swiper-slide-active video');
          if (active) {
            if (active.paused) active.play(); else active.pause();
          }
        }
      });

      // Ensure single-slide centering on small devices
      function updateCenteredOnResize() {
        const w = window.innerWidth;
        if (w < 480) {
          testiSwiper.params.centeredSlides = true;
        } else {
          testiSwiper.params.centeredSlides = false;
        }
        testiSwiper.update();
      }

      window.addEventListener('resize', () => {
        updateCenteredOnResize();
        // force update height after resize
        setTimeout(() => testiSwiper.updateAutoHeight(300), 60);
      });

      updateCenteredOnResize();
    } catch (e) {
      // no-op
    }
  });
})();

/* ----------------------------------
   Events Carousel & Modal
----------------------------------- */
(function initEventsCarouselAndModal(){
  const eventsContainer = document.querySelector('.events-carousel .swiper-container');
  if(!eventsContainer) return;

  // Ensure Swiper library present (reuse loader if already added)
  function ensureSwiper(){
    return new Promise(res=>{
      if(window.Swiper) return res();
      const s = document.createElement('script');
      s.src = 'https://unpkg.com/swiper@6.8.4/swiper-bundle.min.js';
      s.async = true; s.onload = ()=> res();
      document.head.appendChild(s);
    });
  }

  ensureSwiper().then(()=>{
    try {
      // eslint-disable-next-line no-undef
      const eventsSwiper = new Swiper(eventsContainer, {
        loop: false,
        speed: 550,
        spaceBetween: 26,
        slidesPerView: 3,
        watchOverflow: true,
        grabCursor: true,
        breakpoints: {
          0: { slidesPerView: 1, spaceBetween: 16 },
          640: { slidesPerView: 2, spaceBetween: 20 },
          992: { slidesPerView: 3, spaceBetween: 26 }
        },
        navigation: {
          nextEl: '.events-carousel .swiper-button-next',
          prevEl: '.events-carousel .swiper-button-prev'
        },
        pagination: { el: '.events-carousel .swiper-pagination', clickable: true }
      });

      // Basic keyboard nav when carousel focussed
      eventsContainer.addEventListener('keydown', e=>{
        if(e.key === 'ArrowLeft') eventsSwiper.slidePrev();
        if(e.key === 'ArrowRight') eventsSwiper.slideNext();
      });
    } catch(err){ /* no-op */ }
  });

  /* ---------------- Modal Logic ---------------- */
  const modal = document.getElementById('eventModal');
  if(!modal) return;
  const modalTitle = document.getElementById('modalTitle');
  const modalImg = document.getElementById('modalImage');
  const modalTime = document.getElementById('modalTime');
  const modalPrice = document.getElementById('modalPrice');
  const modalDesc = document.getElementById('modalDescription');
  const whatsappBtn = modal.querySelector('.modal-actions a');
  let lastFocused = null;

  const eventData = {
    'bocatas': {
      title: 'Bocatas Hour – Authentic Spanish Sandwich Window',
      time: 'Daily 12:00 pm – 2:00 pm',
      price: '$19.90 (Drink Included)',
      img: './assets/images/bocatas/clandestino-sandwich-02.jpeg',
      description: `
        <p>Enjoy our dedicated mid‑day <strong>artisan bocatas window</strong>: crusty bread, extra virgin olive oil and classic Spanish fillings served fresh.</p>
        <h4>Featured Fillings</h4>
        <ul>
          <li>Serrano Ham & Manchego</li>
          <li>Spanish Tortilla with Alioli</li>
          <li>Ibérico Chorizo & Roasted Peppers</li>
          <li>Tuna with Fire-Roasted Piquillos</li>
        </ul>
        <p>Includes a selected house drink (wine, beer or soft). Limited daily prep – perfect for a quick genuine taste of Spain.</p>
        <p class="cta-note">Reserve ahead via WhatsApp to avoid selling out.</p>
      `
    },
    'senior-day': {
      title: 'Senior Appreciation Tuesday – 20% Off',
      time: 'Every Tuesday',
      price: '20% Off',
      img: './assets/images/gallery/Clandestino-friends-wine.jpeg',
      description: `
        <p>A respectful weekly thank‑you: guests 60+ with valid ID receive <strong>20% off</strong> tapas, wine by the glass and desserts.</p>
        <p>Bring family, share stories and savor traditional Spanish flavors in a relaxed ambience.</p>
        <p class="cta-note">Walk‑ins welcome. Groups encouraged to reserve.</p>
      `
    },
    'womens-day': {
      title: "Women's Wednesday – 50% Off Second Drink",
      time: 'Every Wednesday',
      price: '50% Off 2nd Drink',
      img: './assets/images/events/wednesday.jpg',
      description: `
        <p>Celebrating women every week. Order any qualifying drink and the <strong>second of equal or lesser value is 50% off</strong>.</p>
        <p>Applies to select wines by the glass, vermouth, spritz and signature cocktails.</p>
        <p class="cta-note">Gather your circle and make it a mid‑week ritual.</p>
      `
    },
    'bottle-day': {
      title: 'Spanish Bottle Thursday – 20% Off',
      time: 'Every Thursday',
      price: '20% Off Bottles',
      img: './assets/images/wines.jpeg',
      description: `
        <p>Dive into our curated Spanish wine list with a <strong>20% bottle advantage</strong> every Thursday.</p>
        <p>Ideal for discovering new DO regions or sharing a reserva with friends.</p>
        <p class="cta-note">Ask about staff pairing recommendations.</p>
      `
    },
    'paella-friday': {
      title: 'Paella Fridays – Slow‑Fire Tradition',
      time: 'Fridays 12:00 pm – 4:00 pm (Limited Portions)',
      price: '$15 per serving',
      img: './assets/images/clandestino-paella.jpg',
      description: `
        <p>Classic saffron rice paella cooked in authentic pans – layered flavors that transport you to Valencia.</p>
        <p><strong>Limited batches.</strong> Once the pan is gone, it is gone.</p>
        <p class="cta-note">Pre‑reserve portions via WhatsApp for guaranteed availability.</p>
      `
    },
    'sandwich-day': {
      title: 'Weekend Sandwich Edition – Regional Specials',
      time: 'Every Saturday',
      price: '$19.90 (With Drink)',
      img: './assets/images/bocatas/clandestino-sandwich-01.jpeg',
      description: `
        <p>Elevated weekend versions of our signature Spanish sandwiches inspired by rotating regions.</p>
        <p>Includes selected beverage. Weekly variations keep the experience fresh.</p>
        <p class="cta-note">Follow us for announced fillings every Friday evening.</p>
      `
    },
    'bottle-painting': {
      title: 'Wine Bottle Art Workshop – Creative & Sustainable',
      time: 'Bi‑weekly (Check Dates)',
      price: 'Free Event',
      img: './assets/images/gallery/clandestino-friends-art-5.jpg',
      description: `
        <p>Upcycle empty wine bottles into art. All materials provided – just bring imagination.</p>
        <p>Top seasonal pieces enter a <strong>grand cultural prize selection</strong> focused on Spanish wine & gastronomy.</p>
        <p>Some works are showcased in‑house and at community features.</p>
        <p class="cta-note">Spaces fill quickly. Reserve your spot.</p>
      `
    },
    'wine-tourism': {
      title: 'Spanish Wine Journey – Curated Travel Program',
      time: 'Seasonal',
      price: 'Premium Experience',
      img: './assets/images/NTC-Travels.jpg',
      description: `
        <p>An immersive route across emblematic Spanish wine regions: Rioja, Ribera del Duero, Priorat, Rías Baixas or Jerez (itinerary rotates).</p>
        <p>Includes boutique winery access, guided tastings, regional pairings and producer encounters.</p>
        <p>Enrollment tiers (Gold / Diamond) with limited availability.</p>
        <p class="cta-note">Request the next departure dossier via WhatsApp.</p>
      `
    }
  };

  function trapFocus(e){
    if(!modal.classList.contains('active')) return;
    if(e.key !== 'Tab') return;
    const focusables = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    if(!focusables.length) return;
    const first = focusables[0];
    const last = focusables[focusables.length -1];
    if(e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
    else if(!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
  }

  function openEventModal(id){
    const data = eventData[id]; if(!data) return;
    lastFocused = document.activeElement;
    modalTitle.textContent = data.title;
    modalImg.src = data.img; modalImg.alt = data.title;
    modalTime.textContent = data.time;
    modalPrice.textContent = data.price;
    modalDesc.innerHTML = data.description;
    if(whatsappBtn){
      const base = 'https://wa.me/14086090027?text=';
      const raw = `Hello! I'm interested in the event: ${data.title}. Could you please share availability, booking details and any requirements? Thank you.`;
      const msg = encodeURIComponent(raw);
      whatsappBtn.href = base + msg;
      if(!whatsappBtn.textContent.trim()) whatsappBtn.textContent = 'Request Info via WhatsApp';
      whatsappBtn.setAttribute('aria-label', `Request more information about ${data.title} via WhatsApp`);
    }
    modal.classList.add('active');
    document.body.classList.add('modal-open');
    modal.setAttribute('aria-hidden','false');
    // focus first focusable
    setTimeout(()=>{
      const f = modal.querySelector('button, .modal-close, a.btn');
      if(f) f.focus();
    }, 30);
  }
  function closeEventModal(){
    modal.classList.remove('active');
    document.body.classList.remove('modal-open');
    modal.setAttribute('aria-hidden','true');
    if(lastFocused && lastFocused.focus) lastFocused.focus();
  }

  // Expose globally for inline onclick fallback already in HTML
  window.openEventModal = openEventModal;
  window.closeEventModal = closeEventModal;

  modal.addEventListener('click', e=>{ if(e.target === modal) closeEventModal(); });
  document.addEventListener('keydown', e=>{
    if(e.key === 'Escape' && modal.classList.contains('active')) closeEventModal();
    trapFocus(e);
  });
})();

/* ----------------------------------
   Menu Page Item Reveal Animation
   - Fix: cards were permanently hidden (opacity:0) because .animate-active
     was never applied after refactors. We restore scroll-in reveal with
     IntersectionObserver and a graceful fallback to immediate visibility.
----------------------------------- */
(function initMenuReveal(){
  const cards = document.querySelectorAll('.clandestino-menu-item-card');
  if(!cards.length) return; // Not on menu page
  const sideImgs = document.querySelectorAll('.clandestino-menu-side-image');
  const ctas = document.querySelectorAll('.clandestino-menu-cta-container');
  const all = [...cards, ...sideImgs, ...ctas];

  function activate(el){ el.classList.add('animate-active'); }

  // Fallback (no IO support or user prefers reduced motion) -> show immediately
  const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  if(!('IntersectionObserver' in window) || reduceMotion){
    all.forEach(activate);
    return;
  }

  const io = new IntersectionObserver((entries)=>{
    entries.forEach(en=>{
      if(en.isIntersecting){
        activate(en.target);
        io.unobserve(en.target);
      }
    });
  }, { threshold: 0.15, rootMargin: '0px 0px -5% 0px' });

  all.forEach(el=> io.observe(el));
})();


/* ------------------------------
   Active Navigation Highlighter
   - Adds .active and aria-current="page" to the nav link that matches the current page
   - Falls back to Home (#home or index.html) when no direct file match (e.g., root path)
------------------------------- */
(function setActiveNavigation(){
  const links = document.querySelectorAll('.navbar .navbar-link');
  if(!links.length) return;

  // Current file name (handles trailing slash)
  let path = window.location.pathname.split('/').pop();
  if(path === '' || path === null) path = 'index.html';

  // Normalize: if hash points inside index, treat as index
  const currentHash = window.location.hash;

  // First clear previous states
  links.forEach(a => { a.classList.remove('active'); a.removeAttribute('aria-current'); });

  // Matching strategy:
  // 1. Direct file href match (about.html, wines.html...)
  // 2. If on index.html, prefer link to index.html or #home
  // 3. If hash present and link href equals hash, mark it (used on single-page anchor sections)
  let matched = false;

  links.forEach(a => {
    const href = a.getAttribute('href');
    if(!href) return;
    // Direct full-page match
    if(href === path) {
      a.classList.add('active');
      a.setAttribute('aria-current','page');
      matched = true;
    }
  });

  // Child -> parent mapping: if we're on a specific menu subsection
  if(!matched) {
    const menuChildren = ['tapas.html','wines.html','hampers.html'];
    if(menuChildren.includes(path)) {
      const parent = document.querySelector('.navbar .navbar-link[href="menu.html"]');
      if(parent){
        parent.classList.add('active');
        parent.setAttribute('aria-current','page');
        matched = true;
      }
    }
  }

  if(!matched) {
    // Index / home handling
    if(path === 'index.html') {
      const homeLink = document.querySelector('.navbar .navbar-link[href="#home"], .navbar .navbar-link[href="index.html"]');
      if(homeLink){
        homeLink.classList.add('active');
        homeLink.setAttribute('aria-current','page');
        matched = true;
      }
    }
  }

  if(!matched && currentHash) {
    const hashLink = document.querySelector(`.navbar .navbar-link[href='${currentHash}']`);
    if(hashLink){
      hashLink.classList.add('active');
      hashLink.setAttribute('aria-current','page');
      matched = true;
    }
  }

  // Fallback: if still nothing matched, highlight first nav item to avoid empty state
  if(!matched) {
    const first = links[0];
    if(first){
      first.classList.add('active');
      first.setAttribute('aria-current','page');
    }
  }
})();

/* ----------------------------------
   CLX Contact Form (unique scoped)
---------------------------------- */
(function initClxContactForm(){
  const form = document.getElementById('clx-contact-form');
  if(!form) return;

  const statusEl = form.querySelector('.clx-status');
  const submitBtn = document.getElementById('clx-submit-btn');
  const csrfField = document.getElementById('clx-csrf-token');
  const TOKEN_KEY = 'clx_csrft_v1';

  function genToken(){
    const arr = new Uint32Array(4);
    crypto.getRandomValues(arr);
    return btoa(Array.from(arr).join('-')).replace(/=+/g,'');
  }

  if(!sessionStorage.getItem(TOKEN_KEY)){
    sessionStorage.setItem(TOKEN_KEY, genToken());
  }
  if(csrfField) csrfField.value = sessionStorage.getItem(TOKEN_KEY);

  const fields = ['name','email','tel','subject','message'];

  function setStatus(msg,type,busy){
    if(!statusEl) return;
    statusEl.textContent = msg || '';
    statusEl.className = 'clx-status'+(type? ' clx-status--'+type:'');
    if(busy){ statusEl.setAttribute('aria-busy','true'); } else { statusEl.removeAttribute('aria-busy'); }
  }

  function fieldError(name,msg){
    const errP = form.querySelector('.clx-error[data-error-for="'+name+'"]');
    const input = form.querySelector('[name="'+name+'"]');
    const group = input ? input.closest('.clx-field-group') : null;
    if(errP){ errP.textContent = msg || ''; }
    if(group){ group.classList.toggle('clx-has-error', !!msg); }
    if(msg && input){ input.setAttribute('aria-invalid','true'); } else if(input){ input.removeAttribute('aria-invalid'); }
  }

  function clearErrors(){ fields.forEach(f=>fieldError(f,'')); }

  function validate(){
    clearErrors();
    let ok = true;
    const name = form.name.value.trim();
    if(name.length < 2){ fieldError('name','Enter your full name'); ok=false; }
    const email = form.email.value.trim();
    if(!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)){ fieldError('email','Valid email required'); ok=false; }
    const subject = form.subject.value.trim();
    if(subject.length < 1){ fieldError('subject','Please select a subject'); ok=false; }
    const message = form.message.value.trim();
    if(message.length < 5){ fieldError('message','Message too short'); ok=false; }
    const phone = form.tel.value.trim();
    if(phone && /[^0-9+()\-\s]/.test(phone)){ fieldError('tel','Invalid characters'); ok=false; }
    return ok;
  }

  async function handleSubmit(e){
    e.preventDefault();
    if(submitBtn.classList.contains('is-loading')) return;
    if(!validate()){
      setStatus('Please correct the highlighted fields.', 'error');
      return;
    }
    if(form.website && form.website.value){ // honeypot filled
      setStatus('Unexpected error.', 'error');
      return;
    }
    setStatus('Sending message...', 'info', true);
    submitBtn.classList.add('is-loading');
    submitBtn.disabled = true;

    const data = new FormData(form);
    try {
      const res = await fetch(form.action, {
        method: 'POST',
        headers: { 'Accept':'application/json' },
        body: data,
        credentials: 'same-origin'
      });
      const json = await res.json().catch(()=>({success:false,error:'parse'}));
      if(json.success){
        form.reset();
        // rotate token
        sessionStorage.setItem(TOKEN_KEY, genToken());
        if(csrfField) csrfField.value = sessionStorage.getItem(TOKEN_KEY);
        setStatus('Message sent successfully. Thank you!', 'success');
      } else {
        setStatus(json.errorMessage || 'There was an error sending your message.', 'error');
      }
    } catch(err){
      setStatus('Network error. Please try again.', 'error');
    } finally {
      submitBtn.classList.remove('is-loading');
      submitBtn.disabled = false;
      statusEl?.removeAttribute('aria-busy');
    }
  }

  form.addEventListener('submit', handleSubmit);
})();

/* ----------------------------------
   CLX Contact Form (Clandestino Enhanced)
   - Fixed: No validation errors on page load
   - Validation only triggers after user interaction
   - Clean UX with progressive validation
---------------------------------- */
(function initClandestinoContactForm(){
  'use strict';

  // Configuration
  const CONFIG = {
    formId: 'clx-contact-form',
    csrfTokenId: 'clx-csrf-token',
    submitBtnId: 'clx-submit-btn',
    statusClass: 'clx-status',
    errorClass: 'clx-error',
    loadingClass: 'loading',
    showClass: 'show',
    successClass: 'success',
    errorStateClass: 'error',
    fieldSuccessClass: 'success'
  };

  // DOM Elements
  let elements = {};
  
  // Track which fields have been touched by user
  let touchedFields = {};
  
  // Track if form has been submitted at least once
  let formSubmitted = false;

  // Validation rules
  const validationRules = {
    name: {
      required: true,
      minLength: 2,
      maxLength: 80,
      pattern: /^[a-zA-ZÀ-ÿ\u00f1\u00d1\s\-'\.]+$/,
      message: 'Please enter a valid name (letters only, 2-80 characters)'
    },
    email: {
      required: true,
      maxLength: 120,
      pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      message: 'Please enter a valid email address'
    },
    tel: {
      required: true,
      maxLength: 30,
      pattern: /^[0-9+()\-\s]{6,}$/,
      message: 'Please enter a valid phone number'
    },
    subject: {
      required: true,
      message: 'Please select an inquiry type'
    },
    message: {
      required: true,
      minLength: 5,
      maxLength: 1500,
      message: 'Please enter a message (5-1500 characters)'
    }
  };

  // Initialize form
  function init() {
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initForm);
    } else {
      initForm();
    }
  }

  function initForm() {
    // Cache DOM elements
    cacheElements();
    
    if (!elements.form) {
      // Form not present on this page - exit silently
      return;
    }

    // Generate CSRF token
    generateCSRFToken();
    
    // Bind events
    bindEvents();
    
    // Initial state: button disabled until form is valid
    checkFormCompleteness();
    
    console.log('Clandestino contact form initialized');
  }

  function cacheElements() {
    elements = {
      form: document.getElementById(CONFIG.formId),
      submitBtn: document.getElementById(CONFIG.submitBtnId),
      csrfToken: document.getElementById(CONFIG.csrfTokenId),
      status: document.querySelector('.' + CONFIG.statusClass),
      fields: {}
    };

    // Cache form fields
    if (elements.form) {
      ['name', 'email', 'tel', 'subject', 'message'].forEach(fieldName => {
        const field = elements.form.querySelector(`[name="${fieldName}"]`);
        const errorEl = elements.form.querySelector(`[data-error-for="${fieldName}"]`);
        const fieldGroup = field ? field.closest('.clx-field-group') : null;
        
        if (field) {
          elements.fields[fieldName] = { field, errorEl, fieldGroup };
          touchedFields[fieldName] = false; // Initialize as untouched
        }
      });
    }
  }

  function generateCSRFToken() {
    if (!elements.csrfToken) return;
    
    // Generate a token with timestamp for server-side validation
    const timestamp = Math.floor(Date.now() / 1000);
    const random = Math.random().toString(36).substring(2);
    const token = btoa(`${timestamp}.${random}`);
    elements.csrfToken.value = token;
  }

  function bindEvents() {
    if (!elements.form || !elements.submitBtn) return;

    // Form submission
    elements.form.addEventListener('submit', handleSubmit);

    // Field-level events with progressive validation
    Object.keys(elements.fields).forEach(fieldName => {
      const { field } = elements.fields[fieldName];
      if (!field) return;

      // Mark field as touched on first blur
      field.addEventListener('blur', () => {
        if (!touchedFields[fieldName]) {
          touchedFields[fieldName] = true;
        }
        // Validate only if field has been touched OR form was submitted
        if (touchedFields[fieldName] || formSubmitted) {
          validateField(fieldName);
        }
        checkFormCompleteness();
      });

      // Real-time validation during input (only if already touched or submitted)
      field.addEventListener('input', () => {
        if (touchedFields[fieldName] || formSubmitted) {
          // Clear error immediately on input
          clearFieldError(fieldName);
          
          // Validate after short delay for better UX
          clearTimeout(field._validationTimer);
          field._validationTimer = setTimeout(() => {
            if (touchedFields[fieldName] || formSubmitted) {
              validateField(fieldName);
            }
          }, 300);
        }
        checkFormCompleteness();
      });
    });

    // Prevent form resubmission on refresh
    window.addEventListener('beforeunload', () => {
      if (elements.submitBtn.classList.contains(CONFIG.loadingClass)) {
        return 'Form is being submitted. Are you sure you want to leave?';
      }
    });
  }

  function handleSubmit(e) {
    e.preventDefault();
    
    if (elements.submitBtn.classList.contains(CONFIG.loadingClass)) {
      return; // Already submitting
    }

    // Mark form as submitted to enable all validations
    formSubmitted = true;
    
    // Mark all fields as touched
    Object.keys(touchedFields).forEach(key => {
      touchedFields[key] = true;
    });

    // Validate all fields and show errors
    if (!evaluateFormValidity(true)) {
      return; // Stop if validation fails
    }

    // Submit form
    submitForm();
  }

  /**
   * Validate a single field
   * @param {string} fieldName - The field to validate
   * @param {boolean} showError - Whether to show error visually (default: true)
   * @returns {boolean} - True if valid
   */
  function validateField(fieldName, showError = true) {
    const { field, errorEl, fieldGroup } = elements.fields[fieldName] || {};
    if (!field || !errorEl || !fieldGroup) return true;

    const rule = validationRules[fieldName];
    const value = field.value.trim();

    // Clear previous state
    if (showError) {
      clearFieldError(fieldName);
    }

    // Required validation
    if (rule.required && !value) {
      if (showError) {
        showFieldError(fieldName, rule.message || `${fieldName} is required`);
      }
      return false;
    }

    // Skip other validations if field is empty and not required
    if (!value && !rule.required) {
      return true;
    }

    // Length validation
    if (rule.minLength && value.length < rule.minLength) {
      if (showError) {
        showFieldError(fieldName, `Minimum ${rule.minLength} characters required`);
      }
      return false;
    }

    if (rule.maxLength && value.length > rule.maxLength) {
      if (showError) {
        showFieldError(fieldName, `Maximum ${rule.maxLength} characters allowed`);
      }
      return false;
    }

    // Pattern validation
    if (rule.pattern && !rule.pattern.test(value)) {
      if (showError) {
        showFieldError(fieldName, rule.message);
      }
      return false;
    }

    // Field-specific validation
    if (fieldName === 'subject' && value === '') {
      if (showError) {
        showFieldError(fieldName, 'Please select an inquiry type');
      }
      return false;
    }

    // Mark as valid (only if showing errors)
    if (showError && (touchedFields[fieldName] || formSubmitted)) {
      fieldGroup.classList.add(CONFIG.fieldSuccessClass);
      field.setAttribute('aria-invalid', 'false');
    }
    
    return true;
  }

  function showFieldError(fieldName, message) {
    const { errorEl, fieldGroup, field } = elements.fields[fieldName] || {};
    if (!errorEl || !fieldGroup) return;

    errorEl.textContent = message;
    fieldGroup.classList.add(CONFIG.errorStateClass);
    fieldGroup.classList.remove(CONFIG.fieldSuccessClass);
    if (field) {
      field.setAttribute('aria-invalid', 'true');
      field.setAttribute('aria-describedby', errorEl.id);
    }
  }

  function clearFieldError(fieldName) {
    const { errorEl, fieldGroup, field } = elements.fields[fieldName] || {};
    if (!errorEl || !fieldGroup) return;

    errorEl.textContent = '';
    fieldGroup.classList.remove(CONFIG.errorStateClass);
    if (field) {
      field.removeAttribute('aria-invalid');
      field.removeAttribute('aria-describedby');
    }
  }

  /**
   * Check if form is complete (all required fields filled)
   * This doesn't show visual errors, just enables/disables submit button
   */
  function checkFormCompleteness() {
    let allComplete = true;
    
    Object.keys(validationRules).forEach(fieldName => {
      // Validate without showing errors
      if (!validateField(fieldName, false)) {
        allComplete = false;
      }
    });
    
    setSubmitEnabled(allComplete);
    return allComplete;
  }

  /**
   * Evaluate full form validity with visual feedback
   * Used when submitting form
   */
  function evaluateFormValidity(scrollToError = false) {
    let allValid = true;
    
    Object.keys(validationRules).forEach(fieldName => {
      if (!validateField(fieldName, true)) {
        allValid = false;
      }
    });
    
    setSubmitEnabled(allValid);

    if (!allValid && scrollToError) {
      showStatus('Please correct the highlighted fields.', 'error');
      const firstErrorField = elements.form.querySelector('.clx-field-group.error input, .clx-field-group.error select, .clx-field-group.error textarea');
      if (firstErrorField) {
        firstErrorField.focus({ preventScroll: false });
        firstErrorField.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
      return false;
    }
    return allValid;
  }

  async function submitForm() {
    setLoadingState(true);
    showStatus('Sending your message…', 'info');
    elements.status?.setAttribute('aria-busy', 'true');

    try {
      const formData = new FormData(elements.form);
      
      const response = await fetch('contact.php', {
        method: 'POST',
        body: formData,
        headers: {
          'X-Requested-With': 'XMLHttpRequest'
        }
      });

      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        throw new Error('Server did not return JSON response');
      }

      const result = await response.json();
      
      if (result.success) {
        showStatus('Thank you! Your message has been sent successfully. We\'ll get back to you soon.', 'success');
        resetForm();
        
        // Analytics tracking (if implemented)
        if (typeof gtag !== 'undefined') {
          gtag('event', 'contact_form_submit', {
            'event_category': 'Contact',
            'event_label': formData.get('subject') || 'General'
          });
        }
      } else {
        let errorMessage = 'There was an error sending your message. Please try again.';
        
        if (result.errorMessage) {
          errorMessage = result.errorMessage;
        }
        
        showStatus(errorMessage, 'error');
        
        // Log error details for debugging
        console.error('Form submission failed:', result);
      }
    } catch (error) {
      console.error('Form submission error:', error);
      showStatus('Network error. Please check your connection and try again. If the problem persists, please call us directly.', 'error');
    } finally {
      setLoadingState(false);
      elements.status?.setAttribute('aria-busy', 'false');
    }
  }

  function setLoadingState(loading) {
    if (!elements.submitBtn) return;

    elements.submitBtn.classList.toggle(CONFIG.loadingClass, loading);
    elements.submitBtn.disabled = loading;
    elements.submitBtn.setAttribute('aria-busy', loading ? 'true' : 'false');
    
    if (loading) {
      elements.submitBtn.textContent = 'Sending...';
    } else {
      elements.submitBtn.textContent = 'Send Message';
    }
  }

  function showStatus(message, type) {
    if (!elements.status) return;
    
    const icon = type === 'success' ? 'checkmark-circle-outline' : 
                 (type === 'error' ? 'alert-circle-outline' : 'information-circle-outline');
    
    elements.status.className = `${CONFIG.statusClass}`;
    elements.status.classList.add(CONFIG.showClass, type);
    elements.status.innerHTML = `<div class="clx-status-inner"><ion-icon name="${icon}" aria-hidden="true"></ion-icon><span>${message}</span></div>`;
    elements.status.setAttribute('data-status', type);
    elements.status.setAttribute('role', 'alert');
    elements.status.setAttribute('aria-live', 'polite');

    // Auto-hide success messages after 10 seconds
    if (type === 'success') {
      setTimeout(() => {
        hideStatus();
      }, 10000);
    }

    // Scroll to status message
    setTimeout(() => {
      elements.status.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'nearest' 
      });
    }, 100);
  }

  function hideStatus() {
    if (!elements.status) return;

    elements.status.classList.remove(CONFIG.showClass, 'success', 'error', 'info');
    elements.status.removeAttribute('data-status');
  }

  function setSubmitEnabled(enabled) {
    if (!elements.submitBtn) return;
    elements.submitBtn.disabled = !enabled;
    elements.submitBtn.classList.toggle('disabled', !enabled);
    elements.submitBtn.setAttribute('aria-disabled', !enabled ? 'true' : 'false');
  }

  function resetForm() {
    if (!elements.form) return;

    // Reset form fields
    elements.form.reset();
    
    // Reset touched state
    Object.keys(touchedFields).forEach(key => {
      touchedFields[key] = false;
    });
    
    // Reset form submitted flag
    formSubmitted = false;
    
    // Clear validation states
    Object.keys(elements.fields).forEach(fieldName => {
      clearFieldError(fieldName);
      const { fieldGroup } = elements.fields[fieldName] || {};
      if (fieldGroup) {
        fieldGroup.classList.remove(CONFIG.fieldSuccessClass);
      }
    });

    // Generate new CSRF token
    generateCSRFToken();
    
    // Disable submit button
    setSubmitEnabled(false);
    
    // Focus first field after short delay
    const firstField = elements.form.querySelector('input, select, textarea');
    if (firstField) {
      setTimeout(() => firstField.focus(), 200);
    }
  }

  // Public API (if needed)
  window.ClandestinoContact = {
    validateField,
    resetForm,
    showStatus,
    checkFormCompleteness
  };

  // Initialize when script loads
  init();
})();

/* ----------------------------------
   Temporary Closure Modal
   (Spain Harvest Trip)
----------------------------------- */
function initClosureModal() {
  const modal = document.getElementById('closureModal');
  if (!modal) return;

  const modalContent = modal.querySelector('.closure-modal-content');
  if (!modalContent) return;

  // Show modal
  setTimeout(function() {
    modal.classList.add('active');
    modal.setAttribute('aria-hidden', 'false');
  }, 500);

  // Auto-close after 20 seconds
  let autoCloseTimeout = setTimeout(function() {
    closeModal();
  }, 20000);

  // Close button functionality
  const closeElements = modal.querySelectorAll('[data-modal-close]');
  closeElements.forEach(function(element) {
    element.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      clearTimeout(autoCloseTimeout);
      closeModal();
    });
  });

  // Close when clicking on overlay (but not on content)
  modal.addEventListener('click', function(e) {
    if (e.target === modal) {
      clearTimeout(autoCloseTimeout);
      closeModal();
    }
  });

  // Prevent closing when clicking inside modal content
  modalContent.addEventListener('click', function(e) {
    e.stopPropagation();
  });

  // Close modal function
  function closeModal() {
    modal.classList.remove('active');
    modal.setAttribute('aria-hidden', 'true');
    
    // Stop countdown when modal closes
    if (window.closureCountdownInterval) {
      clearInterval(window.closureCountdownInterval);
      window.closureCountdownInterval = null;
    }
  }

  // Initialize countdown timer
  initCountdownTimer();
}

/* ----------------------------------
   Countdown Timer to November 20, 2025
----------------------------------- */
function initCountdownTimer() {
  // Target date: November 20, 2025 at 2:00 PM
  const targetDate = new Date('2025-11-20T14:00:00').getTime();

  const daysEl = document.getElementById('countdown-days');
  const hoursEl = document.getElementById('countdown-hours');
  const minutesEl = document.getElementById('countdown-minutes');
  const secondsEl = document.getElementById('countdown-seconds');

  if (!daysEl || !hoursEl || !minutesEl || !secondsEl) return;

  function updateCountdown() {
    const now = new Date().getTime();
    const distance = targetDate - now;

    // If countdown is finished
    if (distance < 0) {
      daysEl.textContent = '00';
      hoursEl.textContent = '00';
      minutesEl.textContent = '00';
      secondsEl.textContent = '00';
      
      if (window.closureCountdownInterval) {
        clearInterval(window.closureCountdownInterval);
      }
      return;
    }

    // Calculate time units
    const days = Math.floor(distance / (1000 * 60 * 60 * 24));
    const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((distance % (1000 * 60)) / 1000);

    // Update DOM with zero-padding
    daysEl.textContent = String(days).padStart(2, '0');
    hoursEl.textContent = String(hours).padStart(2, '0');
    minutesEl.textContent = String(minutes).padStart(2, '0');
    secondsEl.textContent = String(seconds).padStart(2, '0');
  }

  // Update immediately
  updateCountdown();

  // Update every second
  window.closureCountdownInterval = setInterval(updateCountdown, 1000);
}

/* ----------------------------------
   Menu Gallery Popup Initialization
   Initialize Magnific Popup for menu product images
----------------------------------- */
function initMenuGallery() {
  // Check if jQuery and Magnific Popup are available
  if (typeof jQuery === 'undefined' || typeof jQuery.fn.magnificPopup === 'undefined') {
    console.warn('jQuery or Magnific Popup not loaded');
    return;
  }

  // Initialize popup for all images with has-popup-image class
  jQuery('.has-popup-image').magnificPopup({
    type: 'image',
    gallery: { 
      enabled: true,
      tPrev: 'Previous',
      tNext: 'Next',
      tCounter: '%curr% of %total%'
    },
    image: { 
      verticalFit: true,
      titleSrc: function(item) {
        return item.el.find('img').attr('alt') || '';
      }
    },
    removalDelay: 160,
    mainClass: 'mfp-fade',
    closeBtnInside: true,
    closeOnContentClick: false,
    closeOnBgClick: true,
    showCloseBtn: true
  });
}

// Initialize menu gallery when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', function() {
    // Wait for jQuery and Magnific Popup to load
    setTimeout(initMenuGallery, 500);
  });
} else {
  // DOM already loaded
  setTimeout(initMenuGallery, 500);
}
